{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _nodeHtmlParser = require(\"node-html-parser\");\n\nvar _constants = require(\"./constants\");\n\nconst MIDDLEWARE_TIME_BUDGET = 10;\nconst MAXIMUM_IMAGE_PRELOADS = 2;\nconst IMAGE_PRELOAD_SIZE_THRESHOLD = 2500;\nconst middlewareRegistry = [];\n\nfunction registerPostProcessor(name, middleware, condition) {\n  middlewareRegistry.push({\n    name,\n    middleware,\n    condition: condition || null\n  });\n}\n\nasync function processHTML(html, data, options) {\n  // Don't parse unless there's at least one processor middleware\n  if (!middlewareRegistry[0]) {\n    return html;\n  }\n\n  const postProcessData = {\n    preloads: {\n      images: []\n    }\n  };\n  const root = (0, _nodeHtmlParser.parse)(html);\n  let document = html; // Calls the middleware, with some instrumentation and logging\n\n  async function callMiddleWare(middleware, name) {\n    let timer = Date.now();\n    middleware.inspect(root, postProcessData, data);\n    const inspectTime = Date.now() - timer;\n    document = await middleware.mutate(document, postProcessData, data);\n    timer = Date.now() - timer;\n\n    if (timer > MIDDLEWARE_TIME_BUDGET) {\n      console.warn(`The postprocess middleware \"${name}\" took ${timer}ms(${inspectTime}, ${timer - inspectTime}) to complete. This is longer than the ${MIDDLEWARE_TIME_BUDGET} limit.`);\n    }\n\n    return;\n  }\n\n  for (let i = 0; i < middlewareRegistry.length; i++) {\n    let middleware = middlewareRegistry[i];\n\n    if (!middleware.condition || middleware.condition(options)) {\n      await callMiddleWare(middlewareRegistry[i].middleware, middlewareRegistry[i].name);\n    }\n  }\n\n  return document;\n}\n\nclass FontOptimizerMiddleware {\n  constructor() {\n    this.fontDefinitions = [];\n\n    this.mutate = async (markup, _data, options) => {\n      let result = markup;\n\n      if (!options.getFontDefinition) {\n        return markup;\n      }\n\n      for (const key in this.fontDefinitions) {\n        const url = this.fontDefinitions[key];\n\n        if (result.indexOf(`<style data-href=\"${url}\">`) > -1) {\n          // The font is already optimized and probably the response is cached\n          continue;\n        }\n\n        const fontContent = options.getFontDefinition(url);\n        result = result.replace('</head>', `<style data-href=\"${url}\">${fontContent}</style></head>`);\n      }\n\n      return result;\n    };\n  }\n\n  inspect(originalDom, _data, options) {\n    if (!options.getFontDefinition) {\n      return;\n    } // collecting all the requested font definitions\n\n\n    originalDom.querySelectorAll('link').filter(tag => tag.getAttribute('rel') === 'stylesheet' && tag.hasAttribute('data-href') && _constants.OPTIMIZED_FONT_PROVIDERS.some(url => {\n      const dataHref = tag.getAttribute('data-href');\n      return dataHref ? dataHref.startsWith(url) : false;\n    })).forEach(element => {\n      const url = element.getAttribute('data-href');\n\n      if (url) {\n        this.fontDefinitions.push(url);\n      }\n    });\n  }\n\n}\n\nclass ImageOptimizerMiddleware {\n  constructor() {\n    this.mutate = async (markup, _data) => {\n      let result = markup;\n\n      let imagePreloadTags = _data.preloads.images.filter(imgHref => !preloadTagAlreadyExists(markup, imgHref)).reduce((acc, imgHref) => acc + `<link rel=\"preload\" href=\"${imgHref}\" as=\"image\"/>`, '');\n\n      return result.replace(/<link rel=\"preload\"/, `${imagePreloadTags}<link rel=\"preload\"`);\n    };\n  }\n\n  inspect(originalDom, _data) {\n    const imgElements = originalDom.querySelectorAll('img');\n    let eligibleImages = [];\n\n    for (let i = 0; i < imgElements.length; i++) {\n      if (isImgEligible(imgElements[i])) {\n        eligibleImages.push(imgElements[i]);\n      }\n\n      if (eligibleImages.length >= MAXIMUM_IMAGE_PRELOADS) {\n        break;\n      }\n    }\n\n    _data.preloads.images = [];\n\n    for (const imgEl of eligibleImages) {\n      const src = imgEl.getAttribute('src');\n\n      if (src) {\n        _data.preloads.images.push(src);\n      }\n    }\n  }\n\n}\n\nfunction isImgEligible(imgElement) {\n  return imgElement.hasAttribute('src') && imageIsNotTooSmall(imgElement) && imageIsNotHidden(imgElement);\n}\n\nfunction preloadTagAlreadyExists(html, href) {\n  const regex = new RegExp(`<link[^>]*href[^>]*${href}`);\n  return html.match(regex);\n}\n\nfunction imageIsNotTooSmall(imgElement) {\n  // Skip images without both height and width--we don't know enough to say if\n  // they are too small\n  if (!(imgElement.hasAttribute('height') && imgElement.hasAttribute('width'))) {\n    return true;\n  }\n\n  try {\n    const heightAttr = imgElement.getAttribute('height');\n    const widthAttr = imgElement.getAttribute('width');\n\n    if (!heightAttr || !widthAttr) {\n      return true;\n    }\n\n    if (parseInt(heightAttr) * parseInt(widthAttr) <= IMAGE_PRELOAD_SIZE_THRESHOLD) {\n      return false;\n    }\n  } catch (err) {\n    return true;\n  }\n\n  return true;\n} // Traverse up the dom from each image to see if it or any of it's\n// ancestors have the hidden attribute.\n\n\nfunction imageIsNotHidden(imgElement) {\n  let activeElement = imgElement;\n\n  while (activeElement.parentNode) {\n    if (activeElement.hasAttribute('hidden')) {\n      return false;\n    }\n\n    activeElement = activeElement.parentNode;\n  }\n\n  return true;\n} // Initialization\n\n\nregisterPostProcessor('Inline-Fonts', new FontOptimizerMiddleware(), // Using process.env because passing Experimental flag through loader is not possible.\n// @ts-ignore\noptions => options.optimizeFonts || process.env.__NEXT_OPTIMIZE_FONTS);\nregisterPostProcessor('Preload Images', new ImageOptimizerMiddleware(), // @ts-ignore\noptions => options.optimizeImages || process.env.__NEXT_OPTIMIZE_IMAGES);\nvar _default = processHTML;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}